#version 430

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D image;

layout(std430, binding = 1) buffer Buffer
{
    uint len;
    vec2 positions[];
} buf;

// TODO: we might want to be more general and allow any camera position and zoom level,
// as this would only require changing the pixel to world position mapping and is trivial.
uniform uint sample_index;
uniform vec2 world_size;
uniform vec2 mouse;


#define PI 3.1415926535897931

#define DIFFUSE 0
#define SPECULAR 1
#define DIELECTRIC 2

#define GEOMETRY_NONE 0
#define GEOMETRY_CIRCLE 1
#define GEOMETRY_LINE 2


struct Material
{
    vec3 albedo;
    vec3 emissivity;
    int type;
};

struct Circle
{
    vec2 center;
    float radius;
    Material material;
};

struct Line
{
    vec2 a;
    vec2 b;
    Material material;
};

// FIXME: these should be defined in a buffer
Circle circles[] =
{
    Circle(vec2(0.8, 0.5), 0.03, Material(vec3(0.75, 0.75, 0.75), vec3(6.0), DIFFUSE)),
    Circle(vec2(0.5, 0.3), 0.15, Material(vec3(0.75, 0.25, 0.25), vec3(0.0), DIELECTRIC)),
    Circle(vec2(0.8, 0.2), 0.05, Material(vec3(0.25, 0.25, 0.75), vec3(0.0), DIELECTRIC)),
    Circle(vec2(0.2, 0.07) + 100.0 * vec2(cos(-2.2), sin(-2.2)), 100.0, Material(vec3(1.0, 1.0, 1.0), vec3(0.0), SPECULAR)),
};
Line lines[] =
{
    Line(vec2(0.1, 0.4), vec2(0.4, 0.6), Material(vec3(1.0, 1.0, 1.0), vec3(0.0), SPECULAR))
};

uint hash(uint x)
{
    x += x << 10;
    x ^= x >> 6;
    x += x << 3;
    x ^= x >> 11;
    x += x << 15;
    return x;
}

float random(inout uint rng_state)
{
    // Returns a value uniformly sampled from [0.0, 1.0]
    // NOTE: can return 1.0 because of floating-point rounding !
    rng_state ^= rng_state << 13;
    rng_state ^= rng_state >> 17;
    rng_state ^= rng_state << 5;
    return float(rng_state) / 4294967296.0;
}

float max_component(vec3 v)
{
    return v.x > v.y && v.x > v.z ? v.x : v.y > v.z ? v.y : v.z;
}

bool intersect_circle(vec2 origin, vec2 direction, vec2 center, float radius, inout float t)
{
    const vec2 oc = center - origin;
    const float oc_dot_dir = dot(oc, direction);
    const float discriminant = oc_dot_dir * oc_dot_dir - dot(oc, oc) + radius * radius;
    if (discriminant < 0.0)
    {
        return false;
    }

    const float sqrt_discriminant = sqrt(discriminant);
    const float t1 = oc_dot_dir - sqrt_discriminant;
    if (t1 > 0.0 && t1 < t)
    {
        t = t1;
        return true;
    }

    const float t2 = oc_dot_dir + sqrt_discriminant;
    if (t2 > 0.0 && t2 < t)
    {
        t = t2;
        return true;
    }

    return false;
}

bool intersect_line(vec2 origin, vec2 direction, vec2 a, vec2 b, inout float t)
{
    const vec2 ab = b - a;
    const float determinant = direction.x * ab.y - direction.y * ab.x;
    if (abs(determinant) < 1e-6) // Parallel
    {
        return false;
    }

    const mat2 mat_inv = 1.0 / determinant * mat2(-direction.y, -ab.y, direction.x, ab.x);
    const vec2 result = mat_inv * (origin - a);
    const float u = result.x;
    const float intersection_t = result.y;
    if (intersection_t > 0.0 && intersection_t < t && u >= 0.0 && u <= 1.0)
    {
        t = intersection_t;
        return true;
    }

    return false;
}

bool intersect(vec2 origin, vec2 direction, out float t, out uint geometry_type, out uint geometry_index)
{
    t = 1e6;
    geometry_type = GEOMETRY_NONE;
    geometry_index = 0xffffffff;

    for (uint i = 0; i < circles.length(); ++i)
    {
        if (intersect_circle(origin, direction, circles[i].center, circles[i].radius, t))
        {
            geometry_type = GEOMETRY_CIRCLE;
            geometry_index = i;
        }
    }
    for (uint i = 0; i < lines.length(); ++i)
    {
        if (intersect_line(origin, direction, lines[i].a, lines[i].b, t))
        {
            geometry_type = GEOMETRY_LINE;
            geometry_index = i;
        }
    }

    return geometry_type != GEOMETRY_NONE;
}

// This uses the technique by Carsten WÃ¤chter and
// Nikolaus Binder from "A Fast and Robust Method for Avoiding
// Self-Intersection" from Ray Tracing Gems (version 1.7, 2020).
vec2 offset_position_along_normal(vec2 position, vec2 normal)
{
    // Convert the normal to an integer offset.
    const ivec2 of_i = ivec2(256.0 * normal);

    // Offset each component of position using its binary representation.
    // Handle the sign bits correctly.
    const vec2 p_i = vec2(
        intBitsToFloat(floatBitsToInt(position.x) + ((position.x < 0.0) ? -of_i.x : of_i.x)),
        intBitsToFloat(floatBitsToInt(position.y) + ((position.y < 0.0) ? -of_i.y : of_i.y)));

    // Use a floating-point offset instead for points near (0,0), the origin.
    const float origin = 1.0 / 32.0;
    const float float_scale = 1.0 / 65536.0;
    return vec2(
        abs(position.x) < origin ? position.x + float_scale * normal.x : p_i.x,
        abs(position.y) < origin ? position.y + float_scale * normal.y : p_i.y);
}

vec2 reflect_diffuse(vec2 normal, inout uint rng_state)
{
    // Random point on a unit circle centered on the normal
    // FIXME: this distribution is probably wrong in 2D !
    const float theta = 2.0 * PI * random(rng_state);
    const vec2 direction = normal + vec2(cos(theta), sin(theta));
    return normalize(direction);
}

vec3 radiance(vec2 origin, vec2 direction, inout uint rng_state)
{
    vec3 accumulated_color = vec3(0.0);
    vec3 accumulated_reflectance = vec3(1.0);

    if ((ivec2(mouse * vec2(imageSize(image))) == ivec2(gl_GlobalInvocationID.xy)))
    {
        buf.len = 0;
    }

    for (uint depth = 0; depth < 16; ++depth)
    {
        float t;
        uint geometry_type;
        uint geometry_index;
        const bool hit = intersect(origin, direction, t, geometry_type, geometry_index);
        // FIXME: this is just a quick fix
        if (!hit || geometry_type != GEOMETRY_CIRCLE)
        {
            return accumulated_color;
        }

        if ((ivec2(mouse * vec2(imageSize(image))) == ivec2(gl_GlobalInvocationID.xy)))
        {
            buf.positions[buf.len] = origin / world_size;
            buf.len += 1;
        }

        // FIXME: this is undefined if there is no hit !!
        const Material material = circles[geometry_index].material;

        const vec3 emissivity = hit ? material.emissivity : vec3(0.0);

        accumulated_color += accumulated_reflectance * emissivity;
        if (!hit)
        {
            return accumulated_color;
        }

        vec3 color = material.albedo;
        const float p = max_component(color);
        if (random(rng_state) < p)
        {
            color /= p;
        }
        else
        {
            return accumulated_color;
        }
        accumulated_reflectance *= color;

        const vec2 hit_pos = origin + t * direction;
        const vec2 object_normal = normalize(hit_pos - circles[geometry_index].center);
        const bool into = dot(direction, object_normal) < 0.0;
        const vec2 normal = into ? object_normal : -object_normal;
        
        switch (material.type)
        {
        case DIFFUSE:
        {
            origin = offset_position_along_normal(hit_pos, normal);
            direction = reflect_diffuse(normal, rng_state);
            break;
        }
        case SPECULAR:
        {
            origin = offset_position_along_normal(hit_pos, normal);
            direction = reflect(direction, normal);
            break;
        }
        case DIELECTRIC:
        {
            const vec2 reflected_dir = direction - 2.0 * object_normal * dot(object_normal, direction);

            const float n_air = 1.0;
            const float n_glass = 1.5;
            const float n_ratio = into ? n_air / n_glass : n_glass / n_air;
            const float dir_dot_normal = dot(direction, normal);
            const float cos2t = 1.0 - n_ratio * n_ratio * (1.0 - dir_dot_normal * dir_dot_normal);
            // Total internal reflection
            if (cos2t < 0.0)
            {
                origin = offset_position_along_normal(hit_pos, normal);
                direction = reflected_dir;
                continue;
            }

            const vec2 transmitted_dir = normalize(direction * n_ratio - object_normal *
                ((into ? 1.0 : -1.0) * (dir_dot_normal * n_ratio + sqrt(cos2t))));

            const float a = n_glass - n_air;
            const float b = n_glass + n_air;
            const float R0 = a * a / (b * b);
            const float c = 1.0 - (into ? -dir_dot_normal : dot(transmitted_dir, object_normal));
            const float Re = R0 + (1.0 - R0) * c * c * c * c * c;
            const float Tr = 1.0 - Re;
            const float P = 0.25 + 0.5 * Re;
            const float RP = Re / P;
            const float TP = Tr / (1.0 - P);
            if (random(rng_state) < P)
            {
                accumulated_reflectance *= RP;
                origin = offset_position_along_normal(hit_pos, normal);
                direction = reflected_dir;
            }
            else
            {
                accumulated_reflectance *= TP;
                origin = offset_position_along_normal(hit_pos, -normal);
                direction = transmitted_dir;
            }
            break;
        }
        }
    }

    return accumulated_color;
}

void main()
{
    const uvec2 image_size = imageSize(image);
    if (gl_GlobalInvocationID.x >= image_size.x || gl_GlobalInvocationID.y >= image_size.y)
    {
        return;
    }

    const uint pixel_index = gl_GlobalInvocationID.y * image_size.x + gl_GlobalInvocationID.x;
    uint rng_state = hash(pixel_index) + hash(sample_index);

    const vec2 ray_origin = (vec2(gl_GlobalInvocationID.xy) + vec2(random(rng_state), random(rng_state))) / vec2(image_size) * world_size;
    const float angle = 2.0 * PI * random(rng_state);
    const vec2 ray_direction = vec2(cos(angle), sin(angle));

    const vec3 radiance_color = radiance(ray_origin, ray_direction, rng_state);
    const vec4 color = vec4(radiance_color, 1.0);

    vec4 average_color = imageLoad(image, ivec2(gl_GlobalInvocationID.xy));
    average_color = (average_color * sample_index + color) / (sample_index + 1);
    imageStore(image, ivec2(gl_GlobalInvocationID.xy), average_color);
}
